<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="简单的说，LayoutInflater就是是一个用来解析xml布局文件的类。该篇文章将对LayoutInflater类进行分析，内容包括： 

LayoutInflater在哪里创建，LayoutInflater来源跟踪
如何获取LayoutInflater对象
LayoutInflater#inflate()方法及其各参数含义
LayoutInflater#inflate()如何加载与解析视图">
<meta property="og:type" content="article">
<meta property="og:title" content="LayoutInflater加载XML布局流程源码分析">
<meta property="og:url" content="http://yoursite.com/2017/10/07/LayoutInflater加载xml布局流程分析/index.html">
<meta property="og:site_name" content="WONDER'TWO">
<meta property="og:description" content="简单的说，LayoutInflater就是是一个用来解析xml布局文件的类。该篇文章将对LayoutInflater类进行分析，内容包括： 

LayoutInflater在哪里创建，LayoutInflater来源跟踪
如何获取LayoutInflater对象
LayoutInflater#inflate()方法及其各参数含义
LayoutInflater#inflate()如何加载与解析视图">
<meta property="og:image" content="http://on1xkrize.bkt.clouddn.com/blog_1007.jpeg">
<meta property="og:updated_time" content="2017-10-07T05:34:44.666Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LayoutInflater加载XML布局流程源码分析">
<meta name="twitter:description" content="简单的说，LayoutInflater就是是一个用来解析xml布局文件的类。该篇文章将对LayoutInflater类进行分析，内容包括： 

LayoutInflater在哪里创建，LayoutInflater来源跟踪
如何获取LayoutInflater对象
LayoutInflater#inflate()方法及其各参数含义
LayoutInflater#inflate()如何加载与解析视图">
<meta name="twitter:image" content="http://on1xkrize.bkt.clouddn.com/blog_1007.jpeg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'WonderTwo[@布鲁克林一棵树]'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/10/07/LayoutInflater加载xml布局流程分析/"/>





  <title> LayoutInflater加载XML布局流程源码分析 | WONDER'TWO </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0af291142256bedaa2172682f765d1c7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">WONDER'TWO</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">好看的皮囊千篇一律，有趣的人格万里挑一！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            博客首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            博客归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            文章标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            博客分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于博主
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/07/LayoutInflater加载xml布局流程分析/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="布鲁克林一棵树">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="WONDER'TWO">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="WONDER'TWO" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                LayoutInflater加载XML布局流程源码分析
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-07T13:14:20+08:00">
                2017-10-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安卓开发相关/" itemprop="url" rel="index">
                    <span itemprop="name">安卓开发相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="http://on1xkrize.bkt.clouddn.com/blog_1007.jpeg" alt=""></p>
<p>简单的说，LayoutInflater就是是一个用来解析xml布局文件的类。该篇文章将对LayoutInflater类进行分析，内容包括： </p>
<ol>
<li>LayoutInflater在哪里创建，LayoutInflater来源跟踪</li>
<li>如何获取LayoutInflater对象</li>
<li>LayoutInflater#inflate()方法及其各参数含义</li>
<li>LayoutInflater#inflate()如何加载与解析视图</li>
</ol>
<a id="more"></a>
<h2 id="一、LayoutInflater来源跟踪"><a href="#一、LayoutInflater来源跟踪" class="headerlink" title="一、LayoutInflater来源跟踪"></a>一、LayoutInflater来源跟踪</h2><p>LayoutInflater和其他系统服务一样，也是在ContextImpl类中进行注册的，ContextImpl类中有一个静态代码块，应用程序用到的系统服务都在这进行注册：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextImpl</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line"></div><div class="line">        <span class="comment">// 注册ActivityManager服务</span></div><div class="line">        registerService(ACTIVITY_SERVICE, <span class="keyword">new</span> ServiceFetcher() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ActivityManager(ctx.getOuterContext(), ctx.mMainThread.getHandler());</div><div class="line">                &#125;&#125;);</div><div class="line">        <span class="comment">// 注册WindowManager服务</span></div><div class="line">        registerService(WINDOW_SERVICE, <span class="keyword">new</span> ServiceFetcher() &#123;</div><div class="line">                Display mDefaultDisplay;</div><div class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">getService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</div><div class="line">                    Display display = ctx.mDisplay;</div><div class="line">                    <span class="keyword">if</span> (display == <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">if</span> (mDefaultDisplay == <span class="keyword">null</span>) &#123;</div><div class="line">                            DisplayManager dm = (DisplayManager)ctx.getOuterContext().</div><div class="line">                                    getSystemService(Context.DISPLAY_SERVICE);</div><div class="line">                            mDefaultDisplay = dm.getDisplay(Display.DEFAULT_DISPLAY);</div><div class="line">                        &#125;</div><div class="line">                        display = mDefaultDisplay;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> WindowManagerImpl(display);</div><div class="line">                &#125;&#125;);</div><div class="line"></div><div class="line">        <span class="comment">// ....</span></div><div class="line"></div><div class="line">        <span class="comment">// 注册LayoutInflater服务</span></div><div class="line">        registerService(LAYOUT_INFLATER_SERVICE, <span class="keyword">new</span> ServiceFetcher() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> PolicyManager.makeNewLayoutInflater(ctx.getOuterContext());</div><div class="line">                &#125;&#125;);</div><div class="line"></div><div class="line">        <span class="comment">// ...其他服务的注册，不一一列举，有兴趣可以自己看源码</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...其他代码</span></div><div class="line"></div><div class="line">    <span class="comment">// 存储所有服务的ServiceFetcher集合</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String, ServiceFetcher&gt; SYSTEM_SERVICE_MAP =</div><div class="line">            <span class="keyword">new</span> HashMap&lt;String, ServiceFetcher&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, ServiceFetcher fetcher)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!(fetcher <span class="keyword">instanceof</span> StaticServiceFetcher)) &#123;</div><div class="line">            fetcher.mContextCacheIndex = sNextPerContextServiceCacheIndex++;</div><div class="line">        &#125;</div><div class="line">        SYSTEM_SERVICE_MAP.put(serviceName, fetcher);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中可以发现，除了LayoutInflater的注册，还有我们常见的WindowManager、ActivityManager等的注册。所有的注册都调用了静态方法：registerService，这里所有的服务并不是在静态代码块中直接创建，而是采用饥渴式方法，只创建了对应服务的获取器ServiceFetcher对象。在真正使用特定服务的时候才创建，SYSTEM_SERVICE_MAP是一个静态的集合对象，存储了所有服务的获取器（ServiceFetcher）对象，map的键是对应服务的名称。只需要调用获取器（ServiceFetcher）的getService(Context context)方法既可以获取对应的系统服务。</p>
<p>我们只关注LayoutInflater的获取器（ServiceFetcher）是如何实现的，其getService(Context context)方法调用了com.android.internal.policy.PolicyManager#makeNewLayoutInflater(Context context)如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LayoutInflater <span class="title">makeNewLayoutInflater</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BridgeInflater(context, RenderAction.getCurrentContext().getProjectCallback());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里提一下，上面代码是android-sdk-21版本的源码，创建了一个BridgeInflater对象，如果是android-sdk-19及以下的源码，PolicyManager#makeNewLayoutInflater方法应该是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LayoutInflater <span class="title">makeNewLayoutInflater</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sPolicy.makeNewLayoutInflater(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着调用了com.android.internal.policy.impl.Policy#makeNewLayoutInflater(Context context)方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">makeNewLayoutInflater</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PhoneLayoutInflater(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说android-sdk-19及以下的版本是创建一个PhoneLayoutInflater对象。</p>
<p>BridgeInflate和PhoneLayoutInflater都是继承自LayoutInflater，实现了解析xml布局的API，将会在后面分析xml布局文件解析过程时用上。这里不讨论两者的实现以及区别。</p>
<h2 id="二、获取LayoutInflater对象"><a href="#二、获取LayoutInflater对象" class="headerlink" title="二、获取LayoutInflater对象"></a>二、获取LayoutInflater对象</h2><p>按照上面的逻辑，LayoutInflater不需要我们自己new，framework层已经帮我们创建好，自然也会也会提供API供开发者获取LayoutInflater对象。</p>
<ul>
<li>既然LayoutInflater是在ContextImpl中注册的，Context也提供了接口来获取LayoutInflater服务，也就是Context#getSystemService(String name);方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">    ServiceFetcher fetcher = SYSTEM_SERVICE_MAP.get(name);</div><div class="line">    <span class="keyword">return</span> fetcher == <span class="keyword">null</span> ? <span class="keyword">null</span> : fetcher.getService(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法从SYSTEM_SERVICE_MAP集合内取出对应服务的获取器ServiceFetcher，并调用其getService方法来获取服务，首次调用的时候，将会调用到ServiceFetcher类的createService方法来创建一个LayoutInflater对象，之后将会返回已经创建好的对象。</p>
<p>所有的其他获取LayoutInflater对象的方式，都将调用到Context#getSystemService(String name);方法，我们继续往下看看其他方式是如何获取的。</p>
<ul>
<li>通过LayoutInflater#from(context)方法来获取：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LayoutInflater <span class="title">from</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    LayoutInflater LayoutInflater =</div><div class="line">            (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</div><div class="line">    <span class="keyword">if</span> (LayoutInflater == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"LayoutInflater not found."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> LayoutInflater;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终该方式还是调用了方式一中说到的Context#getSystemService(String name);方法，并将LayoutInflater服务名称传递进去。</p>
<ul>
<li>如果在Activity内，可以通过Activity#getLayoutInflater();方法获取LayoutInflater，该方法是Activity封装的一个方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@NonNull</span></div><div class="line"><span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">getLayoutInflater</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> getWindow().getLayoutInflater();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Activity里的getWindow返回的是一个PhoneWindow对象，接着看PhoneWindow#getLayoutInflater()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">getLayoutInflater</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mLayoutInflater;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>返回了一个LayoutInflater对象，其初始化是在PhoneWindow的构造方法里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">PhoneWindow</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(context);</div><div class="line">    mLayoutInflater = LayoutInflater.from(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其最终调用了方式二中的LayoutInflater#from(Context context);方法。</p>
<h2 id="三、LayoutInflater-inflate-方法及其各参数含义"><a href="#三、LayoutInflater-inflate-方法及其各参数含义" class="headerlink" title="三、LayoutInflater#inflate()方法及其各参数含义"></a>三、LayoutInflater#inflate()方法及其各参数含义</h2><p>接着，分析LayoutInflater是如何将一个xml布局文件解析成一个View对象的。涉及到以下内容：</p>
<ol>
<li>LayoutInflater#inflate(…)四个重载方法</li>
<li>LayoutInflater#inflate(…)如何解析视图</li>
</ol>
<p>通过LayoutInflater对外提供的四个inflate重载方法是加载布局（解析布局）的入口函数，从这里来入手视图解析流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(@LayoutRes <span class="keyword">int</span> resource, @Nullable ViewGroup root)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(XmlPullParser parser, @Nullable ViewGroup root)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(@LayoutRes <span class="keyword">int</span> resource, @Nullable ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(XmlPullParser parser, @Nullable ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span></span>;</div></pre></td></tr></table></figure>
<p>接下来看一下四个重载的inflate()函数内部的调用关系：第一个重载函数调用了第三个重载函数，第二、三个重载函数最终都调用了第四个重载函数。从调用关系可知，真正开始布局的解析流程的是第四个重载方法，也就是说我们只要分析第四个重载方法的流程就能知道xml布局文件是如何被解析的。如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第三个重载函数内部调用</span></div><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(<span class="keyword">int</span> resource, ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</div><div class="line">    <span class="comment">// ViewGroup 如果要将当前布局放在一个ViewGroup内部，就在这里传入ViewGroup。不需要则传null</span></div><div class="line">    <span class="comment">// attachToRoot </span></div><div class="line">    </div><div class="line">    <span class="keyword">final</span> Resources res = getContext().getResources();</div><div class="line">    <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">        Log.d(TAG, <span class="string">"INFLATING from resource: \""</span> + res.getResourceName(resource) + <span class="string">"\" ("</span></div><div class="line">                + Integer.toHexString(resource) + <span class="string">")"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 通过resource资源文件获取xml解析器</span></div><div class="line">    <span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 调用第四个重构方法</span></div><div class="line">        <span class="keyword">return</span> inflate(parser, root, attachToRoot);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        parser.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 第四个重载函数内部调用</span></div><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(XmlPullParser parser, ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</div><div class="line">    <span class="comment">// parser XML解析器</span></div><div class="line">    <span class="comment">// 省略内容后面分析</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们代码中常用的是第一、三重载函数在加载布局。重点分析一下第三个inflate()函数的各个参数代表什么含义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">/**</span></div><div class="line">     * Inflate a new view hierarchy from the specified xml resource. Throws</div><div class="line">     * &#123;<span class="doctag">@link</span> InflateException&#125; if there is an error.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> resource ID for an XML layout resource to load (e.g.,</div><div class="line">     *        &lt;code&gt;R.layout.main_page&lt;/code&gt;)</div><div class="line">     * <span class="doctag">@param</span> root Optional view to be the parent of the generated hierarchy (if</div><div class="line">     *        &lt;em&gt;attachToRoot&lt;/em&gt; is true), or else simply an object that</div><div class="line">     *        provides a set of LayoutParams values for root of the returned</div><div class="line">     *        hierarchy (if &lt;em&gt;attachToRoot&lt;/em&gt; is false.)</div><div class="line">     * <span class="doctag">@param</span> attachToRoot Whether the inflated hierarchy should be attached to</div><div class="line">     *        the root parameter? If false, root is only used to create the</div><div class="line">     *        correct subclass of LayoutParams for the root view in the XML.</div><div class="line">     * <span class="doctag">@return</span> The root View of the inflated hierarchy. If root was supplied and</div><div class="line">     *         attachToRoot is true, this is root; otherwise it is the root of</div><div class="line">     *         the inflated XML file.</div><div class="line">     */</div><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(@LayoutRes <span class="keyword">int</span> resource, @Nullable ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;...&#125;</div></pre></td></tr></table></figure>
<p>显然resource参数表示传入的布局文件资源ID。重点关注后两个参数。</p>
<h3 id="LayoutInflater-inflate-ViewGroup参数"><a href="#LayoutInflater-inflate-ViewGroup参数" class="headerlink" title="LayoutInflater#inflate()#ViewGroup参数"></a>LayoutInflater#inflate()#ViewGroup参数</h3><p>第二个参数root表示一个ViewGroup实例。如果root不为空，将会调用root的generateLayoutParams方法为xml跟布局生成LayoutParams对象。generateLayoutParams是ViewGroup中定义的方法。它的子类可以对其进行重写，以返回对应类型的LayoutParams。源码如下。</p>
<p>FrameLayout#generateLayoutParams(android.util.AttributeSet)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> LayoutParams <span class="title">generateLayoutParams</span><span class="params">(AttributeSet attrs)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FrameLayout.LayoutParams(getContext(), attrs);        </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RelativeLayout#generateLayoutParams(android.util.AttributeSet)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> LayoutParams <span class="title">generateLayoutParams</span><span class="params">(AttributeSet attrs)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RelativeLayout.LayoutParams(getContext(), attrs);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现，如果传入的root如果是FrameLayout类型，将会生成FrameLayout.LayoutParams，如果传入的root是RelativeLayout，将会生成RelativeLayout.LayoutParams。根据这样的规律，分析下面情况： </p>
<ul>
<li>xml根节点定义了属性<code>android:layout_centerHorizontal=&quot;true&quot;</code>，而inflate()函数传入的root参数为FrameLayout类型，此时<code>android:layout_centerHorizontal</code>将会失效，因为FrameLayout.LayoutParam对象并不支持layout_centerHorizontal属性。</li>
<li>xml根节点定义了属性<code>android:layout_gravity=&quot;center&quot;</code>，而inflate方法传入的的root对象为RelativeLayout类型，此时<code>android:layout_gravity</code>也会失效，因为RelativeLayout.LayoutParams并不支持layout_gravity属性。</li>
<li>同理还需要考虑LinearLayout.LayoutParams所支持的属性与xml根节点定义的属性是否有冲突。</li>
</ul>
<p><strong>如果传入的root对象为空，xml根节点的所有的以“layout_”开头的属性都将失效，因为没有root对象来为根节点生成对应的LayoutParams对象。</strong></p>
<p>针对该特性，如果传入的root为空，将出现类似如根节点定义的宽高失效，如我定义的根节点宽度为50dp，高度也为50dp，最后显示出来的效果却是一个<code>wrap_content</code>的效果。为什么会出现上述原因，是因为如果加载根布局时没有传入root参数，那么也就没有可用LayoutParams对象。那么当这个布局VIEW被add到某一个ViewGroup上的时候，将会自动生成一个宽高为<code>wrap_content</code>的LayoutParams对象。如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ViewGroup#addView(android.view.View, int)：</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot add a null child view to a ViewGroup"</span>);</div><div class="line">    &#125;</div><div class="line">    LayoutParams params = child.getLayoutParams();</div><div class="line">    <span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 如果LayoutParams为空，生成默认LayoutParams对象</span></div><div class="line">        params = generateDefaultLayoutParams();</div><div class="line">        <span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"generateDefaultLayoutParams() cannot return null"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    addView(child, index, params);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ViewGroup#generateDefaultLayoutParams：</span></div><div class="line"><span class="function"><span class="keyword">protected</span> LayoutParams <span class="title">generateDefaultLayoutParams</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="LayoutInflater-inflate-attachToRoot参数"><a href="#LayoutInflater-inflate-attachToRoot参数" class="headerlink" title="LayoutInflater#inflate()#attachToRoot参数"></a>LayoutInflater#inflate()#attachToRoot参数</h3><p>参数attachToRoot表示当前布局生成的view绑定到根布局root上。如果attachToRoot=true，则当前布局view绑定到root，然后inflate()函数会返回根布局root对象作为整个View树的根节点。如果attachToRoot=false，则布局view不会绑定到root，然后inflate()函数会返回布局view作为整个Viwe树的根节点。在这两种情况下，root参数的LayoutParams都会影响布局view的显示样式。其实总结起来，attachToRoot是inflate接收的一个参数，它有两重作用：</p>
<ul>
<li>表示是否需要将解析出来的xml根节点add到传入的root布局中（如果root不为空）</li>
<li>如果attachToRoot为true，则inflate方法将返回root对象，否则将返回解析出来的xml根节点View对象</li>
</ul>
<p>我们代码中使用时一般传入attachToRoot参数为false，也即并没有立即将当前布局view加入根布局（root）。所以一般会稍后调用root.addView()函数将布局view动态添加到父布局中。接下来有同学就有疑问了。当前inflate()加载当前布局不就是为了add到父布局中然后显示在界面上，那为啥要传入attachToRoot=false多此一举，分两步来做这样的事情呢？Android中有些组件是有其自身的“addView”实现机制的，比如Fragment.onCreateView()。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Fragment</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span></div><div class="line">            Bundle savedInstanceState) &#123;</div><div class="line">        <span class="comment">// Fragment组件的“addView”的逻辑由FragmentTransaction 进行处理了</span></div><div class="line">        <span class="comment">// 如果我们这里将attachToRoot设置为true就会有IllegalStateException.</span></div><div class="line">        <span class="comment">// 所以Fragment#onCreateView()中使用inflate()加载布局第三个参数一般传false</span></div><div class="line">        View view = inflater.inflate(R.layout.item_btn, container, <span class="keyword">false</span>);</div><div class="line">        <span class="keyword">return</span> view;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Activvity</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.item_linearout);</div><div class="line">    FragmentManager fragmentManager = getFragmentManager();</div><div class="line">    FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</div><div class="line">    fragmentTransaction.replace(R.id.ll, <span class="keyword">new</span> CustomFragment());</div><div class="line">    fragmentTransaction.commit();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="四、LayoutInflater-inflate-如何解析视图"><a href="#四、LayoutInflater-inflate-如何解析视图" class="headerlink" title="四、LayoutInflater#inflate()如何解析视图"></a>四、LayoutInflater#inflate()如何解析视图</h2><p>其实视图的解析过程可以总结成：</p>
<ul>
<li>使用XmlPullParser遍历xml文件内的所有节点</li>
<li>在遍历到某一节点时，根据节点名字生成对应的View对象</li>
<li>在生成View对象时，将AttributeSet以及Context传递给View对象的构造方法，在构造方法中，View或者其子类将通过AttributeSet获取自身的属性列表，并用来初始化VIEW。如background，color等属性。</li>
</ul>
<p>在分析视图的解析过程之前，需要先了解什么是XmlPullParser，他是第二个和第四个重构方法的参数，XmlPullParser是一个接口，定义了一系列解析xml文件的API。</p>
<p>java中解析xml的常用方式有DOM和SAX两种方式，pull解析是android提供的一种。这里引用一段对pull方式的描述：</p>
<blockquote>
<p>在android系统中，很多资源文件中,很多都是xml格式，在android系统中解析这些xml的方式，是使用pul解析器进行解析的，它和sax解析一样（个人感觉要比sax简单点），也是采用事件驱动进行解析的，当pull解析器，开始解析之后，我们可以调用它的next（）方法，来获取下一个解析事件（就是开始文档，结束文档，开始标签，结束标签），当处于某个元素时可以调用XmlPullParser的getAttributte()方法来获取属性的值，也可调用它的nextText()获取本节点的值。</p>
</blockquote>
<p>对xml解析方式的使用有兴趣可以参阅： <a href="http://www.cnblogs.com/JerryWang1991/archive/2012/02/24/2365507.html" target="_blank" rel="external">Android解析XML总结（SAX、Pull、Dom三种方式）</a></p>
<p>那么XmlPullParser对象是如何生成的。看看重构方法三：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// res是Resource类对象，resource是资源文件id</span></div><div class="line"><span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource);</div></pre></td></tr></table></figure>
<p>看看Resource#getLayout(int id);方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> XmlResourceParser <span class="title">getLayout</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> NotFoundException </span>&#123;</div><div class="line">    <span class="keyword">return</span> loadXmlResourceParser(id, <span class="string">"layout"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Resource#loadXmlResourceParser(int id, String type)方法最终将会返回一个XmlBlock#Parser类型的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBlock</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Parser</span> <span class="keyword">implements</span> <span class="title">XmlResourceParser</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而XmlResourceParser继承自XmlPullParser、AttributeSet以及AutoCloseable（一个定义了不使用时需要关闭的接口）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">XmlResourceParser</span> <span class="keyword">extends</span> <span class="title">XmlPullParser</span>, <span class="title">AttributeSet</span>, <span class="title">AutoCloseable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说最终返回了一个XmlPullParser接口的实现类Parser，Parser类还实现了AttributeSet接口。</p>
<p>那么大家经常在View的构造方法里见到的AttributeSet到底是什么？</p>
<blockquote>
<p>Android引入了pull解析，其中XmlPullParser这个接口定义了操作pull解析方式对xml文件的所有操作接口，包括对节点的操作，对节点内的属性的操作，以及next等接口。而AttributeSet则是Android针对资源文件的特点定义的一个接口，该接口描述了对节点内的属性集的操作接口，除了getAttributeValue、getAttributeCount等一些和XmlPullParser接口相同的接口外。AttributeSet还定义了一些如getIdAttribute、getAttributeResourceValue、getAttributeBooleanValue这些pull解析方式之外的一些带有android特性的接口，相当于是对节点的属性集合的操作接口进行了拓展。</p>
</blockquote>
<p>这样看来，XmlBlock#Parser类除了实现了pull解析方式自带的接口定义外。还实现了AttributeSet接口内定义的一些具有android特性的接口。但是Parser内并未存储节点下所有的Attributes(属性)。这些属性都是存在android.content.res.TypedArray内，而如何得到TypedArray类型对象，继续往下看。</p>
<p>回到LayoutInflater#inflate的第四个重构方法，看看是如何使用parser这个xml解析器的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(XmlPullParser parser, @Nullable ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (mConstructorArgs) &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line"></div><div class="line">        <span class="comment">// 因为parser实现了AttributeSet接口，所以这里是强转</span></div><div class="line">        <span class="keyword">final</span> AttributeSet attrs = Xml.asAttributeSet(parser);</div><div class="line"></div><div class="line">        <span class="comment">// result是需要return的值</span></div><div class="line">        View result = root;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 通过一个循环，寻找根节点</span></div><div class="line">            <span class="keyword">int</span> type;</div><div class="line">            <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</div><div class="line">                    type != XmlPullParser.END_DOCUMENT) &#123;</div><div class="line">                <span class="comment">// Empty</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</div><div class="line">                <span class="comment">// 如果没找到根节点，报错</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(parser.getPositionDescription()</div><div class="line">                        + <span class="string">": No start tag found!"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 找到了根节点，获取根节点的名称</span></div><div class="line">            <span class="keyword">final</span> String name = parser.getName();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</div><div class="line">                <span class="comment">// 如果根节点是merge标签</span></div><div class="line">                <span class="keyword">if</span> (root == <span class="keyword">null</span> || !attachToRoot) &#123;</div><div class="line">                    <span class="comment">// merge标签要求传入的ViewGroup不能是空，并且attachToRoot必须为true， 否则报错</span></div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;merge /&gt; can be used only with a valid "</span></div><div class="line">                            + <span class="string">"ViewGroup root and attachToRoot=true"</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// 递归生成根节点下的所有子节点</span></div><div class="line">                rInflate(parser, root, inflaterContext, attrs, <span class="keyword">false</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 根据节点的信息（名称、属性）生成根节点View对象</span></div><div class="line">                <span class="keyword">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);</div><div class="line"></div><div class="line">                <span class="comment">// 根节点的LayoutParams属性</span></div><div class="line">                ViewGroup.LayoutParams params = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">// 如果传入的ViewGroup不为空</span></div><div class="line"></div><div class="line">                    <span class="comment">// 调用root的generateLayoutParams方法来生成根节点的LayoutParams属性对象</span></div><div class="line">                    params = root.generateLayoutParams(attrs);</div><div class="line">                    <span class="keyword">if</span> (!attachToRoot) &#123;</div><div class="line">                        <span class="comment">// 不需要讲根节点添加到传入的ViewGroup节点下，则将LayoutParams对象设置到根节点内</span></div><div class="line">                        <span class="comment">// 否则的话在后面将会通过addView方式设置params</span></div><div class="line">                        temp.setLayoutParams(params);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">                    System.out.println(<span class="string">"-----&gt; start inflating children"</span>);</div><div class="line">                    <span class="comment">// 开始解析所有子节点</span></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// 解析根节点下的子节点</span></div><div class="line">                rInflateChildren(parser, temp, attrs, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">                    System.out.println(<span class="string">"-----&gt; done inflating children"</span>);</div><div class="line">                    <span class="comment">// 结束了所有子节点的解析</span></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; attachToRoot) &#123;</div><div class="line">                    <span class="comment">// 如果传入的ViewGroup不是空，并且需要添加根节点到其下面</span></div><div class="line">                    root.addView(temp, params);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (root == <span class="keyword">null</span> || !attachToRoot) &#123;</div><div class="line">                    <span class="comment">// 如果根节点为空，或者是attachToRoot为false，返回根节点</span></div><div class="line">                    result = temp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</div><div class="line">            <span class="comment">// ....</span></div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="comment">// ....</span></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">// ....</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// return 结果（根节点或者是传入的ViewGroup）</span></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有几个比较关键的地方，一一进行分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根据节点的信息（名称、属性）生成根节点View对象</span></div><div class="line"><span class="keyword">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);</div></pre></td></tr></table></figure>
<p>createViewFromTag方法创建了对应节点的View对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="function">View <span class="title">createViewFromTag</span><span class="params">(View parent, String name, Context context, AttributeSet attrs,</span></span></div><div class="line">        <span class="keyword">boolean</span> ignoreThemeAttr) &#123;</div><div class="line">    <span class="keyword">if</span> (name.equals(<span class="string">"view"</span>)) &#123;</div><div class="line">        <span class="comment">// 如果节点名字为view，则取节点下面的class属性作为名字</span></div><div class="line">        name = attrs.getAttributeValue(<span class="keyword">null</span>, <span class="string">"class"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 不使用默认Theme属性的这部分逻辑跳过不讲</span></div><div class="line">    <span class="keyword">if</span> (!ignoreThemeAttr) &#123;</div><div class="line">        <span class="keyword">final</span> TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> themeResId = ta.getResourceId(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">if</span> (themeResId != <span class="number">0</span>) &#123;</div><div class="line">            context = <span class="keyword">new</span> ContextThemeWrapper(context, themeResId);</div><div class="line">        &#125;</div><div class="line">        ta.recycle();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 几点名称为blink的时候，创建一个BlinkLayout类对象，继承自FrameLayout。</span></div><div class="line">    <span class="keyword">if</span> (name.equals(TAG_1995)) &#123;</div><div class="line">        <span class="comment">// Let's party like it's 1995!</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlinkLayout(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        View view;</div><div class="line"></div><div class="line">        <span class="comment">// mFactory和mFactory2是两个工厂类，可以对视图的创建进行hook，暂时不分析</span></div><div class="line">        <span class="keyword">if</span> (mFactory2 != <span class="keyword">null</span>) &#123;</div><div class="line">            view = mFactory2.onCreateView(parent, name, context, attrs);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="keyword">null</span>) &#123;</div><div class="line">            view = mFactory.onCreateView(name, context, attrs);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            view = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 和mFactory类似，暂不分析</span></div><div class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span> &amp;&amp; mPrivateFactory != <span class="keyword">null</span>) &#123;</div><div class="line">            view = mPrivateFactory.onCreateView(parent, name, context, attrs);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 最终会走到这，</span></div><div class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// View的构造方法参数：context</span></div><div class="line">            <span class="keyword">final</span> Object lastContext = mConstructorArgs[<span class="number">0</span>];</div><div class="line">            mConstructorArgs[<span class="number">0</span>] = context;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (-<span class="number">1</span> == name.indexOf(<span class="string">'.'</span>)) &#123;</div><div class="line">                    <span class="comment">// 如果节点名字不带"."，说明是系统提供的View(Button/TextView等)，走系统View的创建流程，android.view包下的</span></div><div class="line">                    view = onCreateView(parent, name, attrs);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 否则则说明是自定义View，走自定义View的创建流程</span></div><div class="line">                    view = createView(name, <span class="keyword">null</span>, attrs);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                mConstructorArgs[<span class="number">0</span>] = lastContext;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 返回解析出来的View</span></div><div class="line">        <span class="keyword">return</span> view;</div><div class="line">    &#125; <span class="keyword">catch</span> (InflateException e) &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终会调用LayoutInflater#createView方法来创建指定名字的View（调用onCreateView方法最后也会调用createView方法）。如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">createView</span><span class="params">(String name, String prefix, AttributeSet attrs)</span></span></div><div class="line">            <span class="keyword">throws</span> ClassNotFoundException, InflateException &#123;</div><div class="line">    <span class="comment">// sConstructorMap存储了所有解析过的View的构造方法Constructor</span></div><div class="line">    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);</div><div class="line">    <span class="comment">// 待解析的View的Class</span></div><div class="line">    Class&lt;? extends View&gt; clazz = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 缓存中没有该类型的构造方法，也就是之前没有解析过该Class类型的View，</span></div><div class="line">            <span class="comment">// 通过反射获取Constructor对象，并缓存</span></div><div class="line">            clazz = mContext.getClassLoader().loadClass(</div><div class="line">                    prefix != <span class="keyword">null</span> ? (prefix + name) : name).asSubclass(View.class);</div><div class="line">            <span class="comment">// Filter这个东西是用来拦截节点解析的，</span></div><div class="line">            <span class="comment">// onLoadClass返回false的话，将会调用failNotAllowed，就是报错，不允许解析</span></div><div class="line">            <span class="keyword">if</span> (mFilter != <span class="keyword">null</span> &amp;&amp; clazz != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">boolean</span> allowed = mFilter.onLoadClass(clazz);</div><div class="line">                <span class="keyword">if</span> (!allowed) &#123;</div><div class="line">                    failNotAllowed(name, prefix, attrs);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 反射获取Constructor对象，并缓存</span></div><div class="line">            constructor = clazz.getConstructor(mConstructorSignature);</div><div class="line">            constructor.setAccessible(<span class="keyword">true</span>);</div><div class="line">            sConstructorMap.put(name, constructor);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (mFilter != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// 如果有拦截器的话，需要通过缓存的拦截信息判断是否需要拦截解析，</span></div><div class="line">                <span class="comment">// 如果未缓存拦截信息的话，则动态从mFilter#onLoadClass中取出拦截信息</span></div><div class="line">                Boolean allowedState = mFilterMap.get(name);</div><div class="line">                <span class="keyword">if</span> (allowedState == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">// New class -- remember whether it is allowed</span></div><div class="line">                    clazz = mContext.getClassLoader().loadClass(</div><div class="line">                            prefix != <span class="keyword">null</span> ? (prefix + name) : name).asSubclass(View.class);</div><div class="line"></div><div class="line">                    <span class="keyword">boolean</span> allowed = clazz != <span class="keyword">null</span> &amp;&amp; mFilter.onLoadClass(clazz);</div><div class="line">                    mFilterMap.put(name, allowed);</div><div class="line">                    <span class="keyword">if</span> (!allowed) &#123;</div><div class="line">                        failNotAllowed(name, prefix, attrs);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (allowedState.equals(Boolean.FALSE)) &#123;</div><div class="line">                    failNotAllowed(name, prefix, attrs);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Object[] args = mConstructorArgs;</div><div class="line">        <span class="comment">// View的构造方法里第二个参数是AttributeSet，一个用来解析属性的对象</span></div><div class="line">        args[<span class="number">1</span>] = attrs;</div><div class="line"></div><div class="line">        <span class="comment">// View对象的真正创建</span></div><div class="line">        <span class="keyword">final</span> View view = constructor.newInstance(args);</div><div class="line">        <span class="keyword">if</span> (view <span class="keyword">instanceof</span> ViewStub) &#123;</div><div class="line">            <span class="comment">// 如果是ViewStub的话，需要为其设置一个copy的LayoutInflater</span></div><div class="line">            <span class="keyword">final</span> ViewStub viewStub = (ViewStub) view;</div><div class="line">            viewStub.setLayoutInflater(cloneInContext((Context) args[<span class="number">0</span>]));</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 返回结果</span></div><div class="line">        <span class="keyword">return</span> view;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</div><div class="line">        <span class="comment">// 这个报错比较重要</span></div><div class="line">        InflateException ie = <span class="keyword">new</span> InflateException(attrs.getPositionDescription()</div><div class="line">                + <span class="string">": Error inflating class "</span></div><div class="line">                + (prefix != <span class="keyword">null</span> ? (prefix + name) : name));</div><div class="line">        ie.initCause(e);</div><div class="line">        <span class="keyword">throw</span> ie;</div><div class="line">    &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LayoutInflater是通过反射的方式创建View，并将context以及AttributeSet对象作为参数传入。也就是说如果用户自定义View的时候，没有重写带两个参数的构造方法的话，将会报错。代码将会走到上面NoSuchMethodException这个catch中。例如下面这个报错信息（注意注释部分）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">FATAL EXCEPTION: main</div><div class="line">Process: com.example.j_liuchaoqun.myapplication, PID: 26075</div><div class="line">java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.example.j_liuchaoqun.myapplication/com.example.j_liuchaoqun.myapplication.MainActivity&#125;: android.view.InflateException: Binary XML file line #13: Binary XML file line #13: Error inflating class com.example.j_liuchaoqun.myapplication.SlideTextView</div><div class="line">    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2793)</div><div class="line">    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2864)</div><div class="line">    at android.app.ActivityThread.-wrap12(ActivityThread.java)</div><div class="line">    at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1567)</div><div class="line">    at android.os.Handler.dispatchMessage(Handler.java:102)</div><div class="line">    at android.os.Looper.loop(Looper.java:156)</div><div class="line">    at android.app.ActivityThread.main(ActivityThread.java:6524)</div><div class="line">    at java.lang.reflect.Method.invoke(Native Method)</div><div class="line">    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:941)</div><div class="line">    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:831)</div><div class="line"> Caused by: android.view.InflateException: Binary XML file line #13: Binary XML file line #13: Error inflating class com.example.j_liuchaoqun.myapplication.SlideTextView</div><div class="line"> Caused by: android.view.InflateException: Binary XML file line #13: Error inflating class com.example.j_liuchaoqun.myapplication.SlideTextView</div><div class="line"> </div><div class="line"> // 大家主要看下面这行信息，在createView(LayoutInflater.java:625)方法中反射时</div><div class="line"> // 提示缺少一个SlideTextView(Context context, AttributeSet set)自定义VIEW的构造方法</div><div class="line"> </div><div class="line"> Caused by: java.lang.NoSuchMethodException: &lt;init&gt; [class android.content.Context, interface android.util.AttributeSet]</div><div class="line">    at java.lang.Class.getConstructor0(Class.java:2204)</div><div class="line">    at java.lang.Class.getConstructor(Class.java:1683)</div><div class="line">    at android.view.LayoutInflater.createView(LayoutInflater.java:625)</div><div class="line">    at android.view.LayoutInflater.createViewFromTag(LayoutInflater.java:798)</div><div class="line">    at android.view.LayoutInflater.createViewFromTag(LayoutInflater.java:738)</div><div class="line">    at android.view.LayoutInflater.rInflate(LayoutInflater.java:869)</div><div class="line">    at android.view.LayoutInflater.rInflateChildren(LayoutInflater.java:832)</div><div class="line">    at android.view.LayoutInflater.inflate(LayoutInflater.java:518)</div><div class="line">    at android.view.LayoutInflater.inflate(LayoutInflater.java:426)</div><div class="line">    at android.view.LayoutInflater.inflate(LayoutInflater.java:377)</div><div class="line">    at android.support.v7.app.AppCompatDelegateImplV7.setContentView(AppCompatDelegateImplV7.java:255)</div><div class="line">    at android.support.v7.app.AppCompatActivity.setContentView(AppCompatActivity.java:109)</div><div class="line">    at com.example.j_liuchaoqun.myapplication.MainActivity.onCreate(MainActivity.java:11)</div><div class="line">    at android.app.Activity.performCreate(Activity.java:6910)</div><div class="line">    at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1123)</div><div class="line">    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2746)</div><div class="line">    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2864)</div><div class="line">    at android.app.ActivityThread.-wrap12(ActivityThread.java)</div><div class="line">    at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1567)</div><div class="line">    at android.os.Handler.dispatchMessage(Handler.java:102)</div><div class="line">    at android.os.Looper.loop(Looper.java:156)</div><div class="line">    at android.app.ActivityThread.main(ActivityThread.java:6524)</div><div class="line">    at java.lang.reflect.Method.invoke(Native Method)</div><div class="line">    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:941)</div><div class="line">    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:831)</div></pre></td></tr></table></figure>
<p>在API21中，将会调用到View的一个四个参数的构造方法，低版本API中可能只有三个构造方法，但不管如何，最后都会调用到参数最多的那个构造方法，并在该方法中对View进行初始化，而初始化的信息，都将通过AttributeSet生成的TypedArray对象来获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(context);</div><div class="line"></div><div class="line">    <span class="comment">// 解析styleable.View的所有属性</span></div><div class="line">    <span class="keyword">final</span> TypedArray a = context.obtainStyledAttributes(</div><div class="line">            attrs, com.android.internal.R.styleable.View, defStyleAttr, defStyleRes);</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="comment">// 遍历解析出来的所有属性，并设置为当前View对象</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = a.getIndexCount();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">        <span class="keyword">int</span> attr = a.getIndex(i);</div><div class="line">        <span class="keyword">switch</span> (attr) &#123;</div><div class="line">            <span class="keyword">case</span> com.android.internal.R.styleable.View_background:</div><div class="line">                <span class="comment">// 背景</span></div><div class="line">                background = a.getDrawable(attr);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// ...其他case</span></div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里对其构造方法进行了简化，可以看到，AttributeSet是在这里使用的，通过context.obtainStyledAttributes方法将res/values/attrs.xml资源文件下所定义的这个Viewstyable属性集解析出来，Android源码中的attrs.xml文件中定义了View的所有属性：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">&lt;!-- Attributes that can be used with &#123;@link android.view.View&#125; or</div><div class="line">     any of its subclasses.  Also see &#123;@link #ViewGroup_Layout&#125; for</div><div class="line">     attributes that are processed by the view's parent. --&gt;</div><div class="line">&lt;declare-styleable name="View"&gt;</div><div class="line">    &lt;!-- Supply an identifier name for this view, to later retrieve it</div><div class="line">         with &#123;@link android.view.View#findViewById View.findViewById()&#125; or</div><div class="line">         &#123;@link android.app.Activity#findViewById Activity.findViewById()&#125;.</div><div class="line">         This must be a</div><div class="line">         resource reference; typically you set this using the</div><div class="line">         &lt;code&gt;@+&lt;/code&gt; syntax to create a new ID resources.</div><div class="line">         For example: &lt;code&gt;android:id="@+id/my_id"&lt;/code&gt; which</div><div class="line">         allows you to later retrieve the view</div><div class="line">         with &lt;code&gt;findViewById(R.id.my_id)&lt;/code&gt;. --&gt;</div><div class="line">    &lt;attr name="id" format="reference" /&gt;</div><div class="line"></div><div class="line">    &lt;!-- Supply a tag for this view containing a String, to be retrieved</div><div class="line">         later with &#123;@link android.view.View#getTag View.getTag()&#125; or</div><div class="line">         searched for with &#123;@link android.view.View#findViewWithTag</div><div class="line">         View.findViewWithTag()&#125;.  It is generally preferable to use</div><div class="line">         IDs (through the android:id attribute) instead of tags because</div><div class="line">         they are faster and allow for compile-time type checking. --&gt;</div><div class="line">    &lt;attr name="tag" format="string" /&gt;</div><div class="line"></div><div class="line">    &lt;!-- The initial horizontal scroll offset, in pixels.--&gt;</div><div class="line">    &lt;attr name="scrollX" format="dimension" /&gt;</div><div class="line"></div><div class="line">    &lt;!-- The initial vertical scroll offset, in pixels. --&gt;</div><div class="line">    &lt;attr name="scrollY" format="dimension" /&gt;</div><div class="line"></div><div class="line">    &lt;!-- A drawable to use as the background.  This can be either a reference</div><div class="line">         to a full drawable resource (such as a PNG image, 9-patch,</div><div class="line">         XML state list description, etc), or a solid color such as "#ff000000"</div><div class="line">        (black). --&gt;</div><div class="line">    &lt;attr name="background" format="reference|color" /&gt;</div><div class="line"></div><div class="line">    &lt;!-- Sets the padding, in pixels, of all four edges.  Padding is defined as</div><div class="line">         space between the edges of the view and the view's content. A views size</div><div class="line">         will include it's padding.  If a &#123;@link android.R.attr#background&#125;</div><div class="line">         is provided, the padding will initially be set to that (0 if the</div><div class="line">         drawable does not have padding).  Explicitly setting a padding value</div><div class="line">         will override the corresponding padding found in the background. --&gt;</div><div class="line">    &lt;attr name="padding" format="dimension" /&gt;</div><div class="line">    &lt;!-- Sets the padding, in pixels, of the left edge; see &#123;@link android.R.attr#padding&#125;. --&gt;</div><div class="line">    &lt;attr name="paddingLeft" format="dimension" /&gt;</div><div class="line">    &lt;!-- Sets the padding, in pixels, of the top edge; see &#123;@link android.R.attr#padding&#125;. --&gt;</div><div class="line">    &lt;attr name="paddingTop" format="dimension" /&gt;</div><div class="line">    &lt;!-- Sets the padding, in pixels, of the right edge; see &#123;@link android.R.attr#padding&#125;. --&gt;</div><div class="line">    &lt;attr name="paddingRight" format="dimension" /&gt;</div><div class="line">    &lt;!-- Sets the padding, in pixels, of the bottom edge; see &#123;@link android.R.attr#padding&#125;. --&gt;</div><div class="line">    &lt;attr name="paddingBottom" format="dimension" /&gt;</div><div class="line">    &lt;!-- Sets the padding, in pixels, of the start edge; see &#123;@link android.R.attr#padding&#125;. --&gt;</div><div class="line">    &lt;attr name="paddingStart" format="dimension" /&gt;</div><div class="line">    &lt;!-- Sets the padding, in pixels, of the end edge; see &#123;@link android.R.attr#padding&#125;. --&gt;</div><div class="line">    &lt;attr name="paddingEnd" format="dimension" /&gt;</div><div class="line"></div><div class="line">    &lt;!-- 属性太多，不一一列举 --&gt;</div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure>
<p>当然，如果你是View的子类，也有对应的属性，比如ListView：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name="ListView"&gt;</div><div class="line">    &lt;!-- Reference to an array resource that will populate the ListView.  For static content,</div><div class="line">         this is simpler than populating the ListView programmatically. --&gt;</div><div class="line">    &lt;attr name="entries" /&gt;</div><div class="line">    &lt;!-- Drawable or color to draw between list items. --&gt;</div><div class="line">    &lt;attr name="divider" format="reference|color" /&gt;</div><div class="line">    &lt;!-- Height of the divider. Will use the intrinsic height of the divider if this</div><div class="line">         is not specified. --&gt;</div><div class="line">    &lt;attr name="dividerHeight" format="dimension" /&gt;</div><div class="line">    &lt;!-- When set to false, the ListView will not draw the divider after each header view.</div><div class="line">         The default value is true. --&gt;</div><div class="line">    &lt;attr name="headerDividersEnabled" format="boolean" /&gt;</div><div class="line">    &lt;!-- When set to false, the ListView will not draw the divider before each footer view.</div><div class="line">         The default value is true. --&gt;</div><div class="line">    &lt;attr name="footerDividersEnabled" format="boolean" /&gt;</div><div class="line">    &lt;!-- Drawable to draw above list content. --&gt;</div><div class="line">    &lt;attr name="overScrollHeader" format="reference|color" /&gt;</div><div class="line">    &lt;!-- Drawable to draw below list content. --&gt;</div><div class="line">    &lt;attr name="overScrollFooter" format="reference|color" /&gt;</div><div class="line">&lt;/declare-styleable&gt;</div></pre></td></tr></table></figure>
<p>对应在ListView的构造方法里有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ListView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="keyword">final</span> TypedArray a = context.obtainStyledAttributes(</div><div class="line">            attrs, R.styleable.ListView, defStyleAttr, defStyleRes);</div><div class="line"></div><div class="line">    <span class="comment">// 从节点中获取Divider属性，如果有定义的话，设置到ListView中</span></div><div class="line">    <span class="keyword">final</span> Drawable d = a.getDrawable(R.styleable.ListView_divider);</div><div class="line">    <span class="keyword">if</span> (d != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// Use an implicit divider height which may be explicitly</span></div><div class="line">        <span class="comment">// overridden by android:dividerHeight further down.</span></div><div class="line">        setDivider(d);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 其他ListView提供的属性...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以当你在自定义VIEW时，一般也需要res/values/attrs.xml资源文件下定义Viewstyable属性集，然后再VIEW的构造函数中，使用AttributeSet参数获取到保存这些属性集的TypedArray对象，然后将这些属性一一解析出来并配置给你的自定VIEW。至此，XML布局中根节点的解析过程告一段落。</p>
<p>那么LayoutInflater是如何解析xml下的其他子节点的？回过头来看LayoutInflater#inflate第四个重构方法里有一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 解析根节点下的子节点</span></div><div class="line">rInflateChildren(parser, temp, attrs, <span class="keyword">true</span>);</div></pre></td></tr></table></figure>
<p>该方法将会遍历View所有子节点，并调用createViewFromTag对每一个节点进行解析，并把解析出来的View添加到父节点中。具体内如如何实现，大家可以看看源码。与xml的根节点解析类似。</p>
<hr>
<p>参考文献：</p>
<ol>
<li><a href="http://blog.csdn.net/a740169405/article/details/54580347" target="_blank" rel="external">Android-LayoutInflater布局文件解析过程分析</a></li>
<li><a href="http://blog.csdn.net/guchuanhang/article/details/51197698" target="_blank" rel="external">LayoutInflater.inflate()之attachToRoot</a></li>
<li><a href="http://www.cnblogs.com/JerryWang1991/archive/2012/02/24/2365507.html" target="_blank" rel="external">Android解析XML总结（SAX、Pull、Dom三种方式）</a></li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/13/三级扩展ListView最佳实践/" rel="next" title="三级扩展ListView实现方案最佳实践">
                <i class="fa fa-chevron-left"></i> 三级扩展ListView实现方案最佳实践
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/10/10/android-sqlite-update/" rel="prev" title="数据库升级与数据表新增字段(Android)踩坑记录">
                数据库升级与数据表新增字段(Android)踩坑记录 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="布鲁克林一棵树" />
          <p class="site-author-name" itemprop="name">布鲁克林一棵树</p>
           
              <p class="site-description motion-element" itemprop="description">我是集市里的拾荒者，不看路人，不换爱人！</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">33</span>
                <span class="site-state-item-name">博客</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">43</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="mailto:wondertwo1@163.com" target="_blank" title="邮箱 wondertwo1@163.com">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  邮箱 wondertwo1@163.com
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/wondertwo" target="_blank" title="布鲁克林一棵树—>GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  布鲁克林一棵树—>GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/5182488533" target="_blank" title="布鲁克林一棵树—>微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  布鲁克林一棵树—>微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.cnblogs.com/wondertwo/" target="_blank" title="布鲁克林一棵树—>博客园">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  布鲁克林一棵树—>博客园
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/8f34ca2bf35e" target="_blank" title="布鲁克林一棵树—>简书">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  布鲁克林一棵树—>简书
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、LayoutInflater来源跟踪"><span class="nav-number">1.</span> <span class="nav-text">一、LayoutInflater来源跟踪</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、获取LayoutInflater对象"><span class="nav-number">2.</span> <span class="nav-text">二、获取LayoutInflater对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、LayoutInflater-inflate-方法及其各参数含义"><span class="nav-number">3.</span> <span class="nav-text">三、LayoutInflater#inflate()方法及其各参数含义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LayoutInflater-inflate-ViewGroup参数"><span class="nav-number">3.1.</span> <span class="nav-text">LayoutInflater#inflate()#ViewGroup参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LayoutInflater-inflate-attachToRoot参数"><span class="nav-number">3.2.</span> <span class="nav-text">LayoutInflater#inflate()#attachToRoot参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、LayoutInflater-inflate-如何解析视图"><span class="nav-number">4.</span> <span class="nav-text">四、LayoutInflater#inflate()如何解析视图</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">布鲁克林一棵树</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
